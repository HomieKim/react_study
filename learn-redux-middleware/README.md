# 18장 리덕스 미들웨어를 통한 비동기 작업 관리

리액트 웹애플리케이션에서 API서버를 연동할 때는 API 용청에 대한 상태도 잘 관리해야합니다.
요청이 시작되었을 때는 로딩 중임을, 요청이 성공하거나 실패했을 때는 로딩이 끝났음을 명시해야 합니다.
요청 성공시 서버에서 받아온 응답을 관리하고, 실패할 경우 에러에 대한 상태를 관리해야 합니다.

리액트 프로젝트에서 리덕스를 사용하고 비동기 작업을 관리해야 한다면 미들웨어를 사용하여 효율적으로 상태관리를 할 수 있습니다.



* 18.2 미들웨어란?
    - 리덕스 미들웨어는 액션을 디스패치했을 때 리듀서에서 이를 처리하기에 앞서 사전에 지정된 작업들을 실행합니다.
    - 액션과 리듀서 사이의 중간자리라고 볼 수 있습니다.

* 18.2.1 미들웨어 만들기
    - 실제 프로젝트에서는 대부분 미들웨어를 직접 만들어 사용하지는 않습니다.
    - 미들웨어는 결국 함수를 반환하는 함수를 반환하는 함수 입니다.
    ```javascript
        const loggetMiddleware = function loggerMiddleware(store){
            return function(next){
                return function(action) {
                    // 미들웨어 기본구조
                };
            };
        };
    ```
    - 리덕스 스토어 인스턴스를 파리미터로 받습니다. 
    - next 파라미터는 함수 형태이며, next를 호출하면 그 다음 처리해야 할 미들웨어에게 액션을 넘겨주고, 만약 그 다음 미들웨어가 없다면 리듀서에게 액션을 넘겨줍니다.


* 18.3 비동기 작업을 처리하는 미들웨어 사용
    - 비동기 작업을 처리할 때 사용하는 대표적인 미들웨어는 다음과 같습니다.
    - redux-thunk : 객체가 아닌 함수 형태의 액션을 디스패치할 수 있게 해 줍니다.
    - redux-saga : 특정 액션이 디스패치 되었을 때 정해진 로직에 따라 다른 액션을 디스패치 시키는 규칙을 작성하여 비동기 작업을 처리할 수 있게 해줍니다.

* 18.3.1 redux-thunk
    - Thunk란 특정 작업을 나중에 할 수 있도록 미루기 위해 함수형태로 감싼 것을 의미합니다. 
    - redux-thunk를 사용하면 thunk함수를 만들어서 디스패치할 수 있습니다. 그러면 리덕스 미들웨어가 그 함수를 전달 받아 store의 dispatch와 getState를 파라미터로 넣어서 호출 해 줍니다.
    ```javascript
        const sampleThunk = () => (dispatch, getState)=> {
            // 현재 상태를 참조할 수 있고
            // 새 액션을 디스패치 할 수 있습니다.
        }
    ```
    - redux-thunk는 액션 생성 함수에서 일반 액션 객체를 반환 하는 대신에 함수를 반환합니다.

* 18.3.2 redux-saga
    - redux-thunk는 함수 형태의 액션을 디스패치하여 미들웨어에서 해당 함수에 스토어의 dispatch와 getState를 파라미터로 넣어서 사용하는 원리입니다
    - 다음과 같은 상황에서는 redux-saga를 사용하는 것이 유리합니다.
        1. 기존 요청을 취소 처리해야 할 때(불필요한 중복 요청 방지)
        2. 특정 액션이 발생했을 때 다른 액션을 발생시키거나, API 요청 등 리덕스와 관계없는 코드를 실행 할 때
        3. 웹소켓을 사용할 때
        4. API요청 실패 시 재요청을 해야 할 때

* 18.3.2.1 제네레이터 함수 이해하기
    - redux-saga에서는 ES6의 제너레이터 함ㅅ수라는 문법을 사용합니다. 
    - 이 문법의 핵심 기능은 함수를 작성할 때 함수를 특정 구간에 멈춰 놓을 수도 있고, 원할 때 다시 돌아가게 할 수도 있다는 것 입니다.
    ```javascript
        //예제 코드
        function*  generatorFunction(){
            console.log('안녕하세요');
            yield 1;
            console.log('제네레이터 함수');
            yield 2;
            conssole.log('function*');
            yield 3;
            return 4;
        }
    ```
    - 제네레이터 함수를 만들 때는 function* 키워드를 사용합니다.
    ```javascript
     // 제네레이터 함수를 호출했을 때 반환되는 객체를 제네레이터라고 부릅니다.
     const generator = generatorFunction();

     generator.next();
     // 안녕하세요
     // {value : 1, done : false}
     generator.next();
     // 제네레이터 함수
     // {value : 2, done : false}
     generator.next();
     // function
     // {value : 3, done : false}
     generator.next();
     // {value : 4, done : true}
     generator.next()
     // {value: undefined, done : true}
    ```
    - 제네레이터가 처음 만들어지면 함수의 흐름은 멈춰있는 상태입니다.
    - next() 가 호출되면 다음 yield가 있는 곳까지 호출 하고 다시 함수가 멈춥니다.
    - 제네레이터 함수를 사용하면 함수를 도중에 멈출 수도 있고, 순차적으로 여러 값을 반환시킬 수도 있습니다.
    - next 함수에 파라미터를 넣으면 제네레이터 함수에서 yield를 사용하여 해당 값을 조회할 수 있습니다.    
    - redux-saga는 우리가 디스패치하는 액션을 모니터링해서 그에 따라 필요한 작업을 따로 수행할 수 있는 미들웨어 입니다.
    


